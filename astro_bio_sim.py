# -*- coding: utf-8 -*-
"""astro_bio_sim.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wv1VPYGBqlzWP-KoTla17u-0LJzhCpZL
"""

!pip install opencv-python scikit-learn numpy pandas matplotlib
!pip install opencv-python scikit-learn numpy pandas matplotlib ffmpeg-python

import numpy as np
import cv2
import matplotlib.pyplot as plt
from google.colab.patches import cv2_imshow
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
from matplotlib import animation

# Create Mars terrain simulation
mars_terrain = np.zeros((200, 200, 3), dtype=np.uint8)
rock_positions = [(50, 50), (100, 120), (150, 80)]
for position in rock_positions:
    cv2.circle(mars_terrain, position, 10, (0, 255, 0), -1)

# Object detection
hsv_image = cv2.cvtColor(mars_terrain, cv2.COLOR_BGR2HSV)
lower_green = np.array([40, 40, 40])
upper_green = np.array([80, 255, 255])
green_mask = cv2.inRange(hsv_image, lower_green, upper_green)
contours, _ = cv2.findContours(green_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
detected_rocks = []
for contour in contours:
    x, y, width, height = cv2.boundingRect(contour)
    center = (x + width//2, y + height//2)
    depth = np.random.uniform(0, 30)
    weight = np.random.uniform(0.1, 1.0)
    detected_rocks.append({'position': center, 'depth': depth, 'weight': weight})
    cv2.rectangle(mars_terrain, (x, y), (x+width, y+height), (255, 0, 0), 2)
    cv2.putText(mars_terrain, f'D:{depth:.1f} W:{weight:.2f}', (x, y-10),
                cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 0, 0), 1)

# Classification
np.random.seed(42)
n_samples = 100
spectrometer_data = np.random.normal(500, 100, (n_samples, 3))
labels = np.random.choice([0, 1], n_samples, p=[0.6, 0.4])
pH_values = np.random.uniform(4, 9, n_samples)

# Train model
train_data, test_data, train_labels, test_labels, train_pH, test_pH = train_test_split(
    spectrometer_data, labels, pH_values, test_size=0.3, random_state=42)
classification_model = RandomForestClassifier(n_estimators=10, random_state=42)
classification_model.fit(train_data, train_labels)
predictions = classification_model.predict(test_data)
accuracy = accuracy_score(test_labels, predictions)

# Analyze new rock
new_spectrometer_data = np.array([[450, 520, 480]])
new_pH = np.random.uniform(4, 9)
new_prediction = classification_model.predict(new_spectrometer_data)[0]
analysis_report = f"Sample Analysis: {'Water Trace' if new_prediction == 1 else 'Mineral'}, pH: {new_pH:.2f}"

# Visualization
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))
ax1.imshow(cv2.cvtColor(mars_terrain, cv2.COLOR_BGR2RGB))
ax1.set_title('ERC 2025 Sampling: Rock Detection')
ax2.scatter(test_data[:, 0], test_data[:, 1], c=test_labels, cmap='viridis', alpha=0.7, label='Test Data')
ax2.scatter(new_spectrometer_data[0, 0], new_spectrometer_data[0, 1], c='red', s=100, marker='*', label='New Sample')
ax2.set_title('ERC 2025 Astro-Bio: Classification')
ax2.set_xlabel('Wavelength 1'); ax2.set_ylabel('Wavelength 2')
ax2.legend()
plt.colorbar(ax2.scatter([], [], c=[], cmap='viridis'), ax=ax2, label='Water (1) / Mineral (0)')
plt.tight_layout()
plt.show()
print(f"Model Accuracy: {accuracy:.2f}\nReport: {analysis_report}")

# Animation
fig, ax = plt.subplots()
ax.imshow(cv2.cvtColor(mars_terrain, cv2.COLOR_BGR2RGB))
def animate(frame):
    ax.clear()
    ax.imshow(cv2.cvtColor(mars_terrain, cv2.COLOR_BGR2RGB))
    if frame < len(contours):
        x, y, width, height = cv2.boundingRect(contours[frame])
        center = detected_rocks[frame]['position']
        depth = detected_rocks[frame]['depth']
        weight = detected_rocks[frame]['weight']
        ax.add_patch(plt.Rectangle((x, y), width, height, fill=False, edgecolor='red', linewidth=2))
        ax.text(x, y-10, f'D:{depth:.1f} W:{weight:.2f}', color='red', fontsize=10)
    ax.set_title('ERC 2025 Sampling: Detection Animation')
    return ax,

anim = animation.FuncAnimation(fig, animate, frames=len(contours)+1, interval=1000, blit=False)
anim.save('sampling_demo.mp4', writer='ffmpeg')
plt.show()

